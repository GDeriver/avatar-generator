<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>头像生成器</title>
<style>
  canvas { border: 1px solid #ccc; display: block; margin-bottom: 10px; }
  #stickerInput { margin-bottom: 10px; }
  @font-face { font-family: 'MyFontCN'; src: url('fonts/MyFontCN1.ttf'); }
  @font-face { font-family: 'MyFontEN'; src: url('fonts/MyFontEN3.ttf'); }
</style>
</head>
<body>

<input type="text" id="nickname" placeholder="输入昵称" />
<input type="file" id="stickerInput" accept="image/png" />
<button id="downloadBtn">下载头像</button>
<canvas id="avatarCanvas"></canvas>

<script>
const canvas = document.getElementById('avatarCanvas');
const ctx = canvas.getContext('2d');

// 模板尺寸
const canvasSize = { w: 800, h: 800 };

// 昵称位置与颜色
const namePos = { x: 400, y: 700, color: '#000', font: 'bold 60px MyFontCN' };

// 序号示例
const numberPos = { x: 20, y: 50, color: '#000', font: 'bold 40px MyFontEN' };

// 贴纸相关
let stickerImg = null;
let stickerX = 300, stickerY = 300, stickerW = 150, stickerH = 150;
let isDragging = false, offsetX = 0, offsetY = 0;
let isResizing = false;
const resizeHandleSize = 20;

// 加载字体
function waitFonts() {
  return document.fonts.ready;
}

// 绘制函数
async function draw(number = 1, name = '昵称') {
  await waitFonts();
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      canvas.width = canvasSize.w;
      canvas.height = canvasSize.h;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      // 序号
      ctx.fillStyle = numberPos.color;
      ctx.textAlign = 'left';
      ctx.font = numberPos.font;
      ctx.fillText(`No.${number}`, numberPos.x, numberPos.y);

      // 昵称
      ctx.fillStyle = namePos.color;
      ctx.textAlign = 'center';
      if (/[\u4e00-\u9fa5]/.test(name)) {
        ctx.font = "bold 60px MyFontCN";
      } else {
        ctx.font = "bold 60px MyFontEN";
      }
      ctx.fillText(name, namePos.x, namePos.y);

      // 贴纸
      if (stickerImg) {
        ctx.drawImage(stickerImg, stickerX, stickerY, stickerW, stickerH);
        // 缩放手柄
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(stickerX + stickerW - resizeHandleSize/2,
                     stickerY + stickerH - resizeHandleSize/2,
                     resizeHandleSize, resizeHandleSize);
      }

      resolve();
    };
    img.onerror = reject;
    img.src = 'images/template1.png'; // 模板路径
  });
}

// 下载
document.getElementById('downloadBtn').addEventListener('click', ()=>{
  const link = document.createElement('a');
  link.download = 'avatar.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
});

// 昵称输入实时更新
document.getElementById('nickname').addEventListener('input', e => {
  draw(1, e.target.value);
});

// 贴纸上传
document.getElementById('stickerInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (evt) => {
    stickerImg = new Image();
    stickerImg.onload = () => draw(document.getElementById('nickname').value);
    stickerImg.src = evt.target.result;
  };
  reader.readAsDataURL(file);
});

// 拖拽与缩放事件
canvas.addEventListener('mousedown', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // 缩放手柄
  if (mx >= stickerX + stickerW - resizeHandleSize &&
      mx <= stickerX + stickerW + resizeHandleSize &&
      my >= stickerY + stickerH - resizeHandleSize &&
      my <= stickerY + stickerH + resizeHandleSize) {
    isResizing = true;
  }
  // 拖拽贴纸
  else if (mx >= stickerX && mx <= stickerX + stickerW &&
           my >= stickerY && my <= stickerY + stickerH) {
    isDragging = true;
    offsetX = mx - stickerX;
    offsetY = my - stickerY;
  }
});

canvas.addEventListener('mousemove', e => {
  if (!isDragging && !isResizing) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  if (isDragging) {
    stickerX = mx - offsetX;
    stickerY = my - offsetY;
  }
  if (isResizing) {
    stickerW = mx - stickerX;
    stickerH = my - stickerY;
  }
  draw(document.getElementById('nickname').value);
});

canvas.addEventListener('mouseup', () => {
  isDragging = false;
  isResizing = false;
});

canvas.addEventListener('mouseleave', () => {
  isDragging = false;
  isResizing = false;
});

// 初始化
draw();
</script>

</body>
</html>
